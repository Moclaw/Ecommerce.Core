name: "CI/CD Pipeline - Users Service"

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

env:
  DOTNET_VERSION: "9.0.x"
  APP_NAME: "ecommerce-core"
  DOCKER_IMAGE: "ecom-core-api"
  DOCKER_TAG: "latest"
  CONTAINER_NAME: "ecom-core-api-container"
  API_PORT: 5504

jobs:
  # ==========================================
  # BUILD & TEST JOB
  # ==========================================
  build-and-test:
    name: "Build & Test"
    runs-on: self-hosted

    steps:
      - name: "Checkout Code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Setup .NET"
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: "Cache NuGet packages"
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: "Restore Dependencies"
        run: dotnet restore

      - name: "Build Solution"
        run: dotnet build --configuration Release --no-restore

      - name: "Run Unit Tests"
        run: |
          dotnet test --configuration Release --no-build --verbosity normal

      - name: "Build Docker Image"
        run: |
          echo "Building Docker image..."
          docker build -t ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} -f src/Ecom.Core.API/Dockerfile .
          echo "âœ… Docker image built successfully"

  # ==========================================
  # DEPLOY JOB
  # ==========================================
  deploy:
    name: "Deploy to Development"
    runs-on: self-hosted
    needs: build-and-test

    steps:
      - name: "Checkout Code"
        uses: actions/checkout@v4

      - name: "Setup Environment"
        shell: pwsh
        run: |
          # Ensure logs directory exists
          if (-not (Test-Path "./logs")) {
            New-Item -ItemType Directory -Path "./logs" -Force
          }

      - name: "Stop and Remove Existing Container"
        shell: pwsh
        run: |
          # Check if container exists and stop it
          $containerExists = docker ps -a --format "{{.Names}}" | Select-String "${{ env.CONTAINER_NAME }}"
          if ($containerExists) {
            Write-Host "Stopping existing container..."
            docker stop ${{ env.CONTAINER_NAME }}
            docker rm ${{ env.CONTAINER_NAME }}
          } else {
            Write-Host "No existing container found."
          }

      - name: "Deploy with Docker"
        run: |
          echo "Starting container deployment..."
          
          # Run container with proper configuration
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            --restart unless-stopped \
            -p ${{ env.API_PORT }}:80 \
            -e ASPNETCORE_ENVIRONMENT=Development \
            -v "$(pwd)/logs:/app/logs" \
            --network bridge \
            ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }}
          
          # Display container info
          echo "Container started with ID: $(docker ps -q -f name=${{ env.CONTAINER_NAME }})"

      - name: "Show Container Status"
        run: |
          echo "ðŸš€ Development deployment completed!"
          echo ""
          echo "Docker Container Status:"
          docker ps --filter "name=${{ env.CONTAINER_NAME }}"
          echo ""
          echo "Container Logs:"
          docker logs --tail 20 ${{ env.CONTAINER_NAME }}
          echo ""
          echo "Service URLs:"
          echo "  â€¢ API: http://localhost:${{ env.API_PORT }}"
          echo "  â€¢ Swagger UI: http://localhost:${{ env.API_PORT }}/swagger"

  # ==========================================
  # CLEANUP JOB
  # ==========================================
  cleanup:
    name: "Cleanup"
    runs-on: self-hosted
    needs: deploy
    if: always()

    steps:
      - name: "Archive Logs"
        shell: pwsh
        run: |
          # Create logs archive directory
          $archiveDate = Get-Date -Format "yyyyMMdd"
          $archivePath = "./logs/archive/$archiveDate"
          if (-not (Test-Path $archivePath)) {
            New-Item -ItemType Directory -Path $archivePath -Force
          }

          # Copy current logs
          if (Test-Path "./logs") {
            Copy-Item -Path "./logs/*" -Destination $archivePath -Recurse -Force -ErrorAction SilentlyContinue
          }

          # Compress old logs (older than 7 days)
          Get-ChildItem -Path "./logs/archive" -Recurse -File -Include "*.txt" | Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-7) } | ForEach-Object { gzip $_.FullName }

      - name: "Cleanup Docker Images"
        run: |
          # Remove dangling images
          docker image prune -f
